.SECTION .DATA

.EQU SYS_OPEN, 5
.EQU SYS_WRITE, 4
.EQU SYS_READ, 3
.EQU SYS_CLOSE, 6
.EQU SYS_EXIT, 1


.EQU O_RDONLY, 0
.EQU O_CREAT_WRONLY_TRUNC, 03101


.EQU STDIN, 0
.EQU STDOUT, 1
.EQU STDERR, 2


.EQU LINUX_SYSCALL, 0X80

.EQU END_OF_FILE, 0

.EQU NUMBER_ARGUMENTS, 2

# THIS WILL BE THE ERROR STRING PRINTED TO STDERR.
ERROR_MESSAGE:
    .ASCIZ "AN ERROR OCCURED..."

# SIZE OF ERROR MESSAGE
.EQU ERROR_MESSAGE_SIZE, 19

.SECTION .BSS

.EQU BUFFER_SIZE, 500
.LCOMM BUFFER_DATA, BUFFER_SIZE


.SECTION .TEXT


.EQU ST_SIZE_RESERVE, 8
.EQU ST_FD_IN, -4
.EQU ST_FD_OUT, -8
.EQU ST_ARGC, 0
.EQU ST_ARGV_0, 4
.EQU ST_ARGV_1, 8
.EQU ST_ARGV_2, 12

.GLOBL _START
_START:
    MOVL %ESP, %EBP
    SUBL $ST_SIZE_RESERVE, %ESP

OPEN_FILES:
OPEN_FD_IN:
    MOVL $SYS_OPEN, %EAX
    MOVL ST_ARGV_1(%EBP), %EBX
    MOVL $O_RDONLY, %ECX
    MOVL $0666, %EDX
    INT $LINUX_SYSCALL

ERROR_CHECK_FIRST_OPEN_FILE:
    # IF %EAX IS A NEGATIVE NUMBER, THERE WAS AN ERROR.
    CMPL $0, %EAX
    JLE OPEN_FIRST_FILE_ERROR

    # OTHERWISE CONTINUE WITH THE PROGRAM.
    JGE STORE_FD_IN

# %EAX WAS NEGATIVE, WRITE TO STDERR
OPEN_FIRST_FILE_ERROR:
    # OPEN SYSTEM CALL (4) MOVED INTO %EAX
    MOVL $SYS_WRITE, %EAX
    # MOVE THE STDERR FILE DESCRIPTOR INTO THE %EBX REGISTER
    MOVL $STDERR, %EBX
    # MOVE THE ADDRESS OF THE FIRST CHARACTER IN THE ERROR_MESSAGE STRING INTO THE %ECX REGISTER
    MOVL $ERROR_MESSAGE, %ECX
    # MOVE THE SIZE OF THE STRING (19 BYTES) INTO THE %EDX REGISTER.
    MOVL $ERROR_MESSAGE_SIZE, %EDX
    # TRANSFER CONTROL TO LINUX
    INT $LINUX_SYSCALL
    # IF THERE WAS AN ERROR OPENING THE FIRST FILE, END THE PROGRAM.
    JMP END_PROGRAM

STORE_FD_IN:
    MOVL %EAX, ST_FD_IN(%EBP)

OPEN_FD_OUT:
    MOVL $SYS_OPEN, %EAX
    MOVL ST_ARGV_2(%EBP), %EBX
    MOVL $O_CREAT_WRONLY_TRUNC, %ECX
    MOVL $0666, %EDX
    INT $LINUX_SYSCALL

ERROR_CHECK_SECOND_OPEN_FILE:
    # IF %EAX IS A NEGATIVE NUMBER, THERE WAS AN ERROR.
    CMPL $0, %EAX
    JLE OPEN_SECOND_FILE_ERROR

    # OTHERWISE CONTINUE WITH THE PROGRAM.
    JMP STORE_FD_OUT

OPEN_SECOND_FILE_ERROR:
    # OPEN SYSTEM CALL (4) MOVED INTO %EAX
    MOVL $SYS_WRITE, %EAX
    # MOVE THE STDERR FILE DESCRIPTOR INTO THE %EBX REGISTER
    MOVL $STDERR, %EBX
    # MOVE THE ADDRESS OF THE FIRST CHARACTER IN THE ERROR_MESSAGE STRING INTO THE %ECX REGISTER
    MOVL $ERROR_MESSAGE, %ECX
    # MOVE THE SIZE OF THE STRING (19 BYTES) INTO THE %EDX REGISTER.
    MOVL $ERROR_MESSAGE_SIZE, %EDX
    # TRANSFER CONTROL TO LINUX
    INT $LINUX_SYSCALL
    # IF THERE WAS AN ERROR OPENING THE SECOND FILE, CLOSE THE FIRST FILE AND END THE PROGRAM.
    MOVL $SYS_CLOSE, %EAX
    MOVL ST_FD_IN(%EBP), %EBX
    INT $LINUX_SYSCALL
    JMP END_PROGRAM

STORE_FD_OUT:
    MOVL %EAX, ST_FD_OUT(%EBP)


READ_LOOP_BEGIN:
    MOVL $SYS_READ, %EAX
    MOVL ST_FD_IN(%EBP), %EBX
    MOVL $BUFFER_DATA, %ECX
    MOVL $BUFFER_SIZE, %EDX
    INT $LINUX_SYSCALL

ERROR_CHECK_READ_CALL:
    # IF %EAX IS A NEGATIVE NUMBER, THERE WAS AN ERROR.
    CMPL $0, %EAX
    JLE READ_ERROR

    # OTHERWISE CONTINUE WITH PROGRAM
    JMP READ_LOOP_BEGIN_CONTINUE

READ_ERROR:
    # OPEN SYSTEM CALL (4) MOVED INTO %EAX
    MOVL $SYS_WRITE, %EAX
    # MOVE THE STDERR FILE DESCRIPTOR INTO THE %EBX REGISTER
    MOVL $STDERR, %EBX
    # MOVE THE ADDRESS OF THE FIRST CHARACTER IN THE ERROR_MESSAGE STRING INTO THE %ECX REGISTER
    MOVL $ERROR_MESSAGE, %ECX
    # MOVE THE SIZE OF THE STRING (19 BYTES) INTO THE %EDX REGISTER.
    MOVL $ERROR_MESSAGE_SIZE, %EDX
    # TRANSFER CONTROL TO LINUX
    INT $LINUX_SYSCALL
    # IF THERE WAS AN ERROR READING THE FILE, CLOSE BOTH FILES AND END THE PROGRAM.
    JMP END_LOOP

READ_LOOP_BEGIN_CONTINUE:
    CMPL $END_OF_FILE, %EAX
    JLE END_LOOP

CONTINUE_READ_LOOP:
    PUSHL $BUFFER_DATA
    PUSHL %EAX
    CALL CONVERT_TO_UPPER
    POPL %EAX
    ADDL $4, %ESP

    MOVL %EAX, %EDX
    MOVL $SYS_WRITE, %EAX
    MOVL ST_FD_OUT(%EBP), %EBX
    MOVL $BUFFER_DATA, %ECX
    INT $LINUX_SYSCALL

ERROR_CHECK_WRITE_CALL:
    # IF %EAX IS A NEGATIVE NUMBER, THERE WAS AN ERROR.
    CMPL $0, %EAX
    JLE WRITE_ERROR

    # OTHERWISE CONTINUE WITH THE PROGRAM.
    JMP CONTINUE_READ_LOOP_END

WRITE_ERROR:
    # OPEN SYSTEM CALL (4) MOVED INTO %EAX
    MOVL $SYS_WRITE, %EAX
    # MOVE THE STDERR FILE DESCRIPTOR INTO THE %EBX REGISTER
    MOVL $STDERR, %EBX
    # MOVE THE ADDRESS OF THE FIRST CHARACTER IN THE ERROR_MESSAGE STRING INTO THE %ECX REGISTER
    MOVL $ERROR_MESSAGE, %ECX
    # MOVE THE SIZE OF THE STRING (19 BYTES) INTO THE %EDX REGISTER.
    MOVL $ERROR_MESSAGE_SIZE, %EDX
    # TRANSFER CONTROL TO LINUX
    INT $LINUX_SYSCALL
    # IF THERE WAS AN ERROR WRITING THE FILE, CLOSE BOTH FILES AND END THE PROGRAM.
    JMP END_LOOP

CONTINUE_READ_LOOP_END:
    JMP READ_LOOP_BEGIN

END_LOOP:
    MOVL $SYS_CLOSE, %EAX
    MOVL ST_FD_OUT(%EBP), %EBX
    INT $LINUX_SYSCALL

    MOVL $SYS_CLOSE, %EAX
    MOVL ST_FD_IN(%EBP), %EBX
    INT $LINUX_SYSCALL

END_PROGRAM:
    MOVL $SYS_EXIT, %EAX
    MOVL $0, %EBX
    INT $LINUX_SYSCALL


.EQU LOWERCASE_A, 'A'
.EQU LOWERCASE_Z, 'Z'
.EQU UPPER_CONVERSION, 'A' - 'A'


.EQU ST_BUFFER_LEN, 8
.EQU ST_BUFFER, 12
CONVERT_TO_UPPER:
PUSHL %EBP
MOVL %ESP, %EBP


MOVL ST_BUFFER(%EBP), %EAX
MOVL ST_BUFFER_LEN(%EBP), %EBX
MOVL $0, %EDI
CMPL $0, %EBX
JE END_CONVERT_LOOP

CONVERT_LOOP:
    MOVB (%EAX,%EDI,1), %CL

    CMPB $LOWERCASE_A, %CL
    JL NEXT_BYTE
    CMPB $LOWERCASE_Z, %CL
    JG NEXT_BYTE

    ADDB $UPPER_CONVERSION, %CL
    MOVB %CL, (%EAX,%EDI,1)

NEXT_BYTE:
    INCL %EDI
    CMPL %EDI, %EBX
    JNE CONVERT_LOOP

END_CONVERT_LOOP:
    MOVL %EBP, %ESP
    POPL %EBP
    RET
