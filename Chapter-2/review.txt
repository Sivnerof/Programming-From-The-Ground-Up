Know the Concepts

• Describe the fetch-execute cycle.
    The fetch-execute cycle, also known as the instruction cycle or the fetch–decode–execute cycle, is a process used by a computers CPU (Central Processing Unit) to read instructions from the main memory and execute them.
    Instructions are fetched/executed one at a time in a continuous loop until their are no instructions left (i.e. the computer is powered off).

• What is a register? How would computation be more difficult without registers?
    A register is a section of high-speed memory located within the CPU that holds data to be processed or interpreted at some point.
    Registers can contain data, instructions, or even addresses.
    Without the use of registers the computational process would be slower due to all data, addresses, and instructions needing to be pulled directly from RAM (Random Access Memory).

• How do you represent numbers larger than 255?
    A single bit can hold one of only two values, 0 or 1. By adding another bit we can increase the amount of values we can represent by double.
    So two bits can represent four posible values (2^2 = 4) and with three bits we can represent 8 possible values (2^3 = 8).
    A full byte or 8 bits would give us a range from 0-255 (2^8 = 256) possible values to choose from.
    Therefore, if we wish to represent a number larger than 255, we will need to use more bytes.

• How big are the registers on the machines we will be using?
    The register size (word size) on the machines discussed in the book will all be 4 bytes long.

• How does a computer know how to interpret a given byte or set of bytes of
memory?
    The computer does not know the significance of a number until that number is interpreted.
    Numbers turn into ASCII codes once there is an attempt to display it, same goes for colors.
    The significance of the number is determined by programs, software, or hardware.
    A number can become an address once you choose to look up the byte it points to, and 
    instructions are recognized as such due to a special-purpose register called the instruction pointer.

• What are the addressing modes and what are they used for?
    1. Immediate Mode
        In immediate mode a CPU takes a value (operand) directly from the instruction, instead of loading a value from a location in memory.
        An example would be "Add 5, 3", rather than "Add R0, R1".
    2. Register Addressing Mode
        In register addressing mode the instruction contains a REGISTER from which the operand is to be taken, rather than a location in memory.
        An example would be "Add R1, R2".
    3. Direct Addressing Mode
        In direct addressing mode an operand is taken from an address location in MEMORY.
    4. Indexed Addressing Mode
    5. Indirect Addressing Mode
    6. Base Pointer Addressing Mode

• What does the instruction pointer do?


Use the Concepts

• What data would you use in an employee record? How would you lay it out in
memory?
• If I had the pointer the the beginning of the employee record above, and wanted
to access a particular piece of data inside of it, what addressing mode would I
use?
• In base pointer addressing mode, if you have a register holding the value 3122,
and an offset of 20, what address would you be trying to access?
• In indexed addressing mode, if the base address is 6512, the index register has a
5, and the multiplier is 4, what address would you be trying to access?
• In indexed addressing mode, if the base address is 123472, the index register
has a 0, and the multiplier is 4, what address would you be trying to access?
• In indexed addressing mode, if the base address is 9123478, the index register
has a 20, and the multiplier is 1, what address would you be trying to access?


Going Further

• What are the minimum number of addressing modes needed for computation?
• Why include addressing modes that aren’t strictly needed?
• Research and then describe how pipelining (or one of the other complicating
factors) affects the fetch-execute cycle.
• Research and then describe the tradeoffs between fixed-length instructions and
variable-length instructions.
